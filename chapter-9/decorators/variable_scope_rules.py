'''
Note that the output starts with 3, 
which proves that the print(a) statement was executed.
But the second one, print(b), never runs.
When I first saw this I was surprised,
thinking that 6 should be printed,
because there is a global variable b and the assignment
to the local b is made after print(b).

'''

'''

But the fact is, when Python compiles the body of the function,
it decides that b is a local variable because it is assigned
within the function. The generated bytecode reflects this decision
and will try to fetch b from the local scope.
Later, when the call f2(3) is made, the body of f2 fetches and prints the value
of the local variable a, but when trying to fetch the value of local variable b
it discovers that b is unbound.

'''

'''

This is not a bug, but a design choice:
Python does not require you to declare variables,
but assumes that a variable assigned in the body of a function is local.

'''

'''

If we want the interpreter to treat b as a global variable and
still assign a new value to it within the function,
we use the global declaration:

'''

'''

There is one other scope where variables can come from,
which we call nonlocal and is fundamental for closures.

'''

b = 6

def f2(a):
    print(a)
    print(b)
    b = 6

def f3(a):
    global b
    print(a)
    print(b)
    b = 9

if __name__ == "__main__":
    f2(3)